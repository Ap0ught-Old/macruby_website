--- 
title:      Real-world dynamic bundle creation
created_at: 2010-08-08 23:41:08.125402 +01:00
updated_at: 2010-08-08 23:41:08.125777 +01:00
tutorial:   true
author:     Nick Ludlam
filter:
  - erb
  - textile
--- 
h1(title). <%= h(@page.title) %>

<div class="author">
  By <%= member_name(@page.author) %>
</div>

<div class='tutorial'>

In this tutorial we will examine a real-world case of wanting to read ID3 tags from MP3 files in a quick and efficient manner from MacRuby. The solution must also be packagable, so we can build a stand-alone version of the application, free of any specific system dependencies.

While there are some existing gems to read ID3 tags, the native Ruby implentation, <em>id3lib-ruby</em>, does not compile with the current version (0.6 as of this tutorial creation) of MacRuby, and the other gem (id3) complicates portability by wrapping a C library.

To bring about a cleaner solution, we can take advantage of MacRuby's ability to load Objective-C bundles at runtime. The Objective-C layer of these bundles can be a very thin wrapper around native C or C++ calls, giving us a powerful flexibility to pull in any kind of compiled code we choose. In doing this, we can also ensure that the library is built as a fat binary, ensuring maximum compatibility with end users.

h3. Preparation

The framework chosen was one called TagLib (<a href="http://developer.kde.org/~wheeler/taglib.html">developer.kde.org/~wheeler/taglib.html</a>), which is a nicely clean and portable C++ implementation.

Conveniently, a user on GitHub has already done some of the work for us in making an XCode project which builds a Framework of this library. After forking and cloning this Git project, we can start to build our Obj-C wrapper class around the library's functionality. We can get the basic Framework project set up with the following:

<pre class="commands">
git clone http://github.com/rahvin/TagLib.framework.git
cd TagLib.framework
wget http://developer.kde.org/~wheeler/files/src/taglib-1.6.3.tar.gz
tar zxvf taglib-1.6.3.tar.gz
mv taglib-1.6.3 taglib-src
</pre>

You can use the latest revision of TagLib, but this example will reference the 1.6.3 release.

The last thing we need to do to the existing Framework target is add in the C wrapper functionality, which is an optional part of TagLib. We will utilise these C bindings later on, as they simplify the amount of code we need to write, and handle much of the UTF-8 string conversion for us.

Select "Add to Project..." from the Project menu, and navigate to "taglib-src/bindings/c/", and add both "tag_c.cpp" and "tag_c.h". If you build the project at this stage, there should be no errors. So far, so good.

h3. Adding our Bundle target

The first thing we need to do is add a new Target to our project. Select "New Target..." from the Project menu, and select "Loadable Bundle". Call this <code>TagLibBundle</code>. 

Open up the "Compile Sources" folder inside the "TagLib" Framework target. Shift-select every file in this folder, and open "Get Info" in the File menu. Open up the Targets tab at the top, and check the tickbox next to <code>TagLibBundle</code>. This ensures that every file used to compile the framework is also used to compile our new bundle target. This also reveals certain configuration options within the project build settings.

Open the <code>TagLibBundle</code> target info pane, and search for "Preprocessor Macros". Add <code>HAVE_CONFIG_H</code> to this entry. This is related to the way the project has been ported from the Autoconf setup of the original source code, and is required to build properly.


!{width:600px;padding:20px 0px}/images/realworld-dynamic-bundles/preprocessor_macros.png!


While this view is open, we also need to remove the entries under "Prefix Header"


!{width:600px;padding:20px 0px}/images/realworld-dynamic-bundles/remove_prefix_header.png!


and "Other Linker Flags". These are set up by default, and are not required for our bundle.


!{width:600px;padding:20px 0px}/images/realworld-dynamic-bundles/remove_other_linker_flags.png!

Lastly, we enable garbage collection support.

!{width:600px;padding:20px 0px}/images/realworld-dynamic-bundles/enable_gc.png!

Now swap to the "General" tab and ensure that we are linking the project against the "Foundation" framework and "libz" shared library. Check that the project builds without errors at this stage.


h3. Adding our Objective-C wrapper class

Now comes the fun part. We write a very simple Objective-C class to wrap the C functionality of the <code>TagLib</code> code.

We will take a very simplistic approach in building the wrapper, as this ensures easy memory management. Our class will have an <code>initWithFileAtPath:</code> method, which we will use to initialise our class, and perform the scan of the file for tags. The tags themselves will be placed inside an <code>NSDictionary</code> to be read at a later point. Lastly the <code>dealloc</code> method will release the <code>NSDictionary</code>. All of the potentially tricky memory management is contained only within the <code>initWithFileAtPath:</code> method, and occurs within a single method invocation.

Now we need to add an Objective-C class which will perform our wrapping duties. Add a new Objective-C file named "TagLib.m" to the project, subclassed from <code>NSObject</code>. Ensure that is is only part of the TagLibBundle target.


!{width:600px;padding:20px 0px}/images/realworld-dynamic-bundles/new_wrapper_class.png!


Add a new Objective-C file to the <code>TagLibBundle</code> target called <code>TagLib.m</code>. Once we synthesize a simple <code>NSDictionary</code> to contain our tag, our header looks like:

<% coderay :lang => 'c' do -%>
@interface TagLib : NSObject {
    NSDictionary *tags;
}

@property (nonatomic, retain) NSDictionary *tags;

@end
<% end %>

and our <code>TagLib.m</code> file:

<% coderay :lang => 'c' do -%>

void Init_TagLibBundle(void) { }

@implementation TagLib

@synthesize tags;

- (id)init {
    if (self = [super init]) {
        self.tags = [NSDictionary dictionary];
    }

    return self;
}

- (void)dealloc {
    [tags release]; tags = nil;
    [super dealloc];
}

@end

<% end %>

The <code>Init_TagLibBundle</code> c method declaration is required to identify this as a MacRuby bundle. When loading a bundle with <code>require</code> from within MacRuby, it will automatically look for a method with the signature <code>Init_XXX</code> where XXX is the Product Name taken from the Target settings.

Now most of the code for our <code>initWithFileAtPath:</code> has already been implemented in "taglib-src/examples/tagreader_c.c".  We start off by opening the file, and initializing taglib:

<% coderay :lang => 'c' do -%>

- (id)initWithFileAtPath:(NSString *)filePath {
  if (self = [super init]) {

    // Our mutable dictionary in which we add the tags
    NSMutableDictionary *tempDictionary = [NSMutableDictionary dictionary];

    TagLib_File *file;
    TagLib_Tag *tag;
    
    // We want UTF8 strings out of TagLib
    taglib_set_strings_unicode(TRUE);

    file = taglib_file_new([filePath cStringUsingEncoding:NSUTF8StringEncoding]);

    if (file != NULL) {
      tag = taglib_file_tag(file);
      ...
<% end %>

After initialisation, we can try reading a single tag from the opened file with the following:

<% coderay :lang => 'c' do -%>
      ...
      if (taglib_tag_title(tag) != NULL &&
        strlen(taglib_tag_title(tag)) > 0) {
        NSString *title = [NSString stringWithCString:taglib_tag_title(tag)
                                             encoding:NSUTF8StringEncoding];
        [tempDictionary setObject:title forKey:@"title"];
      }
      ...
<% end %>

Lastly, we clean up the allocated memory, close the file, and convert the NSMutableDictionary into an NSDictionary:

<% coderay :lang => 'c' do -%>
      ...
      taglib_tag_free_strings();
      taglib_file_free(file);
      
    }

    self.tags = [NSDictionary dictionaryWithDictionary:tempDictionary];
    [tempDictionary release];
  }
  
  return self;
}

<% end %>

So now we have a simple class which should place the title tag of the file into the <code>tags</code> dictionary. The last thing we need to set up with XCode is a small build script to copy the Mach-O binary out of the standard Mac OS X bundle structure. We need direct access to the Mach-O binary bundle, as it is this we use from within MacRuby.

We accomplish this with a small "Run Script Build Phase" added to the bundle target:

<% coderay :lang => 'sh' do -%>
  cp -v "${TARGET_BUILD_DIR}/${EXECUTABLE_PATH}"
        "${SOURCE_ROOT}/${FULL_PRODUCT_NAME}"
<% end %>

Now we can build the target, and a file called "TagLib.bundle" should appear in the project root. Now from a terminal, we can quickly test out the newly built bundle using the "macirb" command-line ruby interpreter:

<% coderay :lang => 'ruby' do -%>
$ macirb
irb(main):001:0> require 'TagLibBundle'
=> true
irb(main):002:0> test = TagLib.alloc.initWithFileAtPath("test.mp3")
=> #<TagLib:0x200090880>
irb(main):003:0> test.tags[:title]
=> "Mmm Skyscraper I Love You"
irb(main):004:0> 
<% end %>

The code for this example is available on GitHub: <a href="http://github.com/nickludlam/TagLib.framework">http://github.com/nickludlam/TagLib.framework</a>.

</div>