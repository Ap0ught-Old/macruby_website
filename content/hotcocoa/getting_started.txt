---
title:      HotCocoa Tutorial -- Getting Started
created_at: 2009-05-29 22:09:00.0 -05:00
updated_at: 2009-05-29 22:09:00.0 -05:00
tutorial:   true
author:     dj2
filter:
  - erb
  - textile
---
h1(title). <%= h(@page.title) %>

<div class="author">
  By <%= member_name(@page.author) %>
</div>

<div class='tutorial'>

h3. Introduction

I've had my eye on giving "HotCocoa":http://www.macruby.org/trac/wiki/HotCocoa a test run for a while now. Other things have conspired to come up over the last few months so I haven't had a chance to give it a spin. That is, until now. I started poking at it the other day, a few things still confuse me, but I'm getting there.

I figured I'd write stuff down as I plow my way through the code and create a simple little application. The application is nothing fancy, I'm going to query "PostRank":http://www.postrank.com and pull back engagement information on a feed entered into a text box. This will be a multi-part tutorial.

In the usual fashion, let's start at the start. What is HotCocoa? Well, HotCocoa is a layer of Ruby code that sits on top of the Mac OS X frameworks including "Cocoa":http://developer.apple.com/cocoa/. HotCocoa is part of the "MacRuby":http://www.macruby.org distribution which will ship with figure versions of OS X. MacRuby is a port of Ruby 1.9 to run on top of Objective-C.

I'm going to assume you have MacRuby installed for this tutorial.

The HotCocoa developers makes life easy to get started developing your application. There is a <code>hotcocoa</code> command that is installed when you install MacRuby. This will create the basic application structure and Rakefile to get you up and running.

<% coderay :lang => 'sh' do -%>
titania:Development dj2$ hotcocoa Postie
<% end %>

<img class="alignleft" src="/images/hotcocoa/getting_started.png" />We can then execute our application by changing into the <em>Postie</em> directory and executing <code>macrake</code>. <strong>Note</strong>, this uses <em>mac</em>rake and not regular rake. MacRuby installs alongside the normal Ruby runtime on OS X. You'll need to make sure you use <em>macrake</em>, <em>macirb</em>, <em>macgem</em> and <em>macruby</em> to work with the MacRuby versions.  You should see a <em>Hello from HotCooca</em> window if everything worked correctly.

You'll notice that you now have a Postie.app in your root directory. This application can be executed by double clicking like any other Mac application, although, you'll need MacRuby installed for it to execute. You can also execute <code>macruby lib/application.rb</code> to execute the application. This allows passing flags to <em>macruby</em> for things like enabling debug mode.

Let's take a quick look at the files generated by the <em>hotcocoa</em> command.

<% coderay :lang => 'sh' do -%>
./Rakefile
./config/build.yml
./resources/HotCocoa.icns
./lib/application.rb
./lib/menu.rb
<% end %>

The <em>build.yml</em> file contains information used by <em>hotcocoa</em> to build your application. This includes things like the name, version, icon and source files. The icon, by default, is <em>HotCocoa.icns</em>. The main files we're interested in are <em>application.rb</em> and <em>menu.rb</em>.

<% coderay :lang => 'ruby' do -%>
module HotCocoa
  def application_menu
    menu do |main|
      main.submenu :apple do |apple|
        apple.item :about, :title => "About #{NSApp.name}"
        apple.separator
        apple.item :preferences, :key => ","
        apple.separator
        apple.submenu :services
        apple.separator
        apple.item :hide, :title => "Hide #{NSApp.name}", :key => "h"
        apple.item :hide_others, :title => "Hide Others", :key => "h", :modifiers => [:command, :alt]
        apple.item :show_all, :title => "Show All"
        apple.separator
        apple.item :quit, :title => "Quit #{NSApp.name}", :key => "q"
      end
      main.submenu :file do |file|
        file.item :new, :key => "n"
        file.item :open, :key => "o"
      end
      main.submenu :window do |win|
        win.item :minimize, :key => "m"
        win.item :zoom
        win.separator
        win.item :bring_all_to_front, :title => "Bring All to Front", :key => "o"
      end
      main.submenu :help do |help|
        help.item :help, :title => "#{NSApp.name} Help"
      end
    end
  end
end
<% end %>

The <em>menu.rb</em> file contains information about the menu for our applcation. This includes the menu names, hot keys, modifiers and general layout.

The <em>:apple</em> submenu is special and will appear with a menu title based on your application name, as is typical for OS X applications. For the other submenus, by default, the menu title will be the capitalized version of the symbol name converted to a string. You can also provide a <code>:title => 'foo'</code> option to specify a different name. <code>menu.submenu :postrank, :title => 'PostRank'</code>.

The symbol provided to each submenu <em>item</em>, e.g. <em>file.item :new</em> will be used to form the name of the method invoked in your application delegate. The methods are named <em>on_<key></em>. For our <em>:new</em> item the <em>on_new</em> menu item will be invoked. If there is no <em>on_<key></em> method the menu item will be disabled. As you can see above you can also specify <em>:modifiers</em> and <em>:key</em> equivalents for your items.

As with the menu titles, the items names will be formed from capitalizing the symbol provided unless a <em>:title</em> is provided.

In the case of <em>Postie</em> I've erased everything but the <em>:apple</em> submenu for now. I don't need any extra menu items at the moment. This also means all of the <em>on_*</em> methods can be removed from <em>application.rb</em>.

The default <em>application.rb</em> provided by the <em>hotcocoa</em> command is pretty short.

<% coderay :lang => 'ruby' do -%>
require 'hotcocoa'

class Application
  include HotCocoa

  def start
    application(:name => "Postie") do |app|
      app.delegate = self
      window(:frame => [100, 100, 500, 500], :title => "Postie") do |win|
        win << label(:text => "Hello from HotCocoa", :layout => {:start => false})
        win.will_close { exit }
      end
    end
  end
end

Application.new.start
<% end %>

Let's take a quick look and see if we can figure out what's going on. We need to <code>require hotcocoa'</code> to get access to the needed HotCocoa classes. We then <code>include HotCocoa</code> into our <code>Application</code> class to make everything shorter. Feel free to rename <em>Application</em> just do it in the class definition and at the bottom of the file.

Jumping to the bottom, you can see we're calling <code>Application.new.start</code> so the  <code>Application#start</code> method will be invoked. It's worth noting, the application will not return from <code>Application#start</code>.

Going back to <code>Application#start</code> we call <code>application</code> to create our application, setting the title as desired. We then set ourselves as the application delegate. This means that our class will receive all of the callbacks that are called on the Cocoa application. This includes the menu <code>on_*</code>callbacks we talked about earlier.

We then proceed to create a <code>window</code>. We're setting a <em>:frame</em> on the window to position it at X 100, Y 100 (from the bottom left) with a width of 500 and height of 500. We <em>:title</em> the window as <em>Postie</em>.  If you don't want to specify the entire frame of the window you can specify just the <em>:size => [500, 500]</em> of the window. You can also specify <em>:center => true</em> to center the window on the desktop. If you look at the Objective-C documentation for NSWindow the options available in Obj-C are available in the HotCocoa layer.

Once the window is created we add a <code>label</code> to the window and set the <code>will_close</code> handler to <code>exit</code> when executed.

The <code>will_close</code> callback is the HotCocoa name for the Cocoa <code>windowWillClose:</code>. Many of the Cocoa callbacks have been remapped to make the names more Ruby like.

<table>
<tr>
 <th>Cocoa Callback</th>
 <th>HotCocoa Callback</th>
</tr>
<tr>
 <td>window:shouldDragDocumentWithEvent:from:withPasteboard:</td>
 <td>should_drag_document?(shouldDragDocumentWithEvent, from, withPasteboard)</td>
</tr>
<tr>
  <td>window:shouldPopUpDocumentPathMenu:</td>
  <td>should_popup_path_menu?(shouldPopUpDocumentPathMenu)</td>
</tr>
<tr>  
  <td>window:willPositionSheet:usingRect:</td>
  <td>will_position_sheet(willPositionSheet, usingRect)</td>
</tr>
<tr>
  <td>windowDidBecomeKey:</td>
  <td>did_become_key</td>
</tr>  
<tr>
  <td>windowDidBecomeMain:</td>
  <td>did_become_main</td>
</tr>  
<tr>
  <td>windowDidChangeScreen:</td>
  <td>did_change_screen</td>
</tr>  
<tr>
  <td>windowDidChangeScreenProfile:</td>
  <td>did_change_screen_profile</td>
</tr>  
<tr>
  <td>windowDidDeminiaturize:</td>
  <td>did_deminiturize</td>
</tr>  
<tr>
  <td>windowDidEndSheet:</td>
  <td>did_end_sheet</td>
</tr>  
<tr>
  <td>windowDidExpose:</td>
  <td>did_expose(windowDidExpose.userInfo['NSExposedRect'])</td>
</tr>  
<tr>
  <td>windowDidMiniaturize:</td>
  <td>did_miniaturize</td>
</tr>  
<tr>
  <td>windowDidMove:</td>
  <td>did_move</td>
</tr>  
<tr>
  <td>windowDidResignKey:</td>
  <td>did_resign_key</td>
</tr>  
<tr>
  <td>windowDidResignMain:</td>
  <td>did_resign_main</td>
</tr>  
<tr>
  <td>windowDidResize:</td>
  <td>did_resize</td>
</tr>  
<tr>
  <td>windowDidUpdate:</td>
  <td>did_update</td>
</tr>  
<tr>
  <td>windowShouldClose:</td>
  <td>should_close?</td>
</tr>  
<tr>
  <td>windowShouldZoom:toFrame:</td>
  <td>should_zoom?(toFrame)</td>
</tr>  
<tr>
  <td>windowWillBeginSheet:</td>
  <td>will_begin_sheet</td>
</tr>  
<tr>
  <td>windowWillClose:</td>
  <td>will_close</td>
</tr>  
<tr>
  <td>windowWillMiniaturize:</td>
  <td>will_miniaturize</td>
</tr>  
<tr>
  <td>windowWillMove:</td>
  <td>will_move</td>
</tr>  
<tr>
  <td>windowWillResize:toSize:</td>
  <td>will_resize(toSize)</td>
</tr>  
<tr>
  <td>windowWillReturnFieldEditor:toObject:</td>
  <td>returning_field_editor(toObject)</td>
</tr>  
<tr>
  <td>windowWillReturnUndoManager:</td>
  <td>returning_undo_manager</td>
</tr>  
<tr>
  <td>windowWillUseStandardFrame:defaultFrame:</td>
  <td>will_use_standard_frame(defaultFrame)</td>
</tr>
</table>

That's it for part I. We've now setup with our basic application structure and have an idea of what we're working with. In the next installment, we'll work on getting our application views setup as we want.

<a href="/hotcocoa/application_layout.html">Read the next article: "Application Layout"</a>
</div>